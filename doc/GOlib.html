<html><HEAD>
<LINK REL=StyleSheet HREF="style.css" TYPE="text/css" MEDIA=screen>
<LINK REL=StyleSheet HREF="style-print.css" TYPE="text/css" MEDIA=print>
</HEAD> <body>

<h1>GOLib - A library for handling gene ontologies</h1>
<index name="GOLib">
<p>GOLib is an open source python library for handling of gene ontology (GO) databases released under the GPL licence
<a href="http://www.geneontology.org/GO.doc.shtml"> (More about GO).</a> It is designed for fast searching and ease of use by using the power of python's expresive powers 
combined with the speed of a C implemented search algorithm.
</p>

<p>Some of the basic uses that GOLib is sutible for:
<ul>
  <li>GO term manipulation in python</li>
  <li>Searcing the GO for relevant terms</li>
  <li>...</li>
</ul>

<h2>Downloading and loading the database</h2>
<p><b><code>setDataDir(dataDir)</code></b></p>
<index name ="setDataDir">
<p>Set the data directory where the annotation and ontology files are stored (by default a directory named data
located where the GOLib is instaled e.g. ...site-packages/GOLib/data)</p>
<p class=section>Arguments</p>
<dl class=arguments>
  <dt>dataDir</dt>
  <dd>Path to the local data</dd>
</dl>
<br>

<p><b><code>getDataDir()</code></b></p>
<index name="getDataDir">
<p>Get the data directory where the annotation and ontology files are stored (by default a directory named data 
located where the GOLib is instaled e.g. ...site-packages/GOLib/data)</p>

<p><b><code>downloadGO()</code></b></p>
<index name = "downloadGO">
<p>Downloads the curent gene ontology from 
<a href="http://www.geneontology.org/ontology/gene_ontology.obo">http://www.geneontology.org/ontology/gene_ontology.obo</a> and saves on a local drive (You can specifie where with the <code>setDataDir</code> function</p>
<br>

<p><b><code>loadAnnotation(organism="sgd", forceReload=False, progressCallback=None)</code></b></p>
<index name="loadAnnotation">
<p>Loads the annotation for the specified organism</p>
<p class=section>Arguments</p>
<dl class=arguments>
  <dt>organism</dt>
  <dd>Abbreviation of the organism you want to download (you can get the list of all available organisms with <code>listorganisms()</code> call).</dd>
  <dt>forceReload</dt>
  <dd>If True it will reload the database even if it is already loaded.</dd>
</dl>
<br>

<p><b><code>loadGO(forceReload=False, progressCallback=None)</code></b></p>
<index name="loadGO">
<p>Loads the ontology from 'data_dir//gene_ontlogy.obo' where data_dir is set using setDataDir (default: .//data)</p>
<p class=section>Arguments</p>
<dl class=arguments>
  <dt>forceReload</dt>
  <dd>If True it will reload the database even if it is already loaded.</dd>
</dl>
<br>

<p><b><code>downloadAnnotation(organism="sgd")</code></b></p>
<index name = "downloadAnnotation">
<p>Downloads the annotation for the specified organism (e.g. "sgd", "fb", "mgi",...)</p>
<p class=section>Arguments</p>
<dl class=arguments>
  <dt>organism</dt>
  <dd>Abbreviation of the organism you want to download (you can get the list of all available organisms with <code>listorganisms()</code> call).</dd>
</dl>
<br>

<p><b><code>listOrganisms()</code></b></p>
<index neme = "listOrganisms">
<p>Connect to <a href="http://www.geneontology.org/GO.current.annotations.shtml">http://www.geneontology.org/GO.current.annotations.shtml</a>, parse out the organism names
appearing in the table, and return the list of organisms.</p>
<br>

<p><b><code><index>listDownloadedOrganisms()</index></code></b></p>
<index name ="listDownloadedOrganisms">
<p>Returns a list with organism names off all local downloaded annotations</p>
<XMP class=code>>>> import go
>>> go.downloadGO()
>>> go.listDownloadedorganisms()
['ddb', 'sgd']
>>> go.listorganisms()
['tigr_Aphagocytophilum', 'tair', 'tigr_Banthracis', 'goa_cow', 'tigr_Chydrogeno
formans', 'wb', 'tigr_Cjejuni', 'cgd', 'tigr_Cburnetii', 'zfin', 'tigr_Dethenoge
nes', 'ddb', 'fb', 'tigr_Echaffeensis', 'goa_chicken', 'tigr_Gsulfurreducens', '
goa_human', 'GeneDB_Lmajor', 'tigr_Lmonocytogenes', 'tigr_Mcapsulatus', 'mgi', '
tigr_Nsennetsu', 'gramene_oryza', 'goa_pdb', 'GeneDB_Pfalciparum', 'pseudocap',
'tigr_Psyringae', 'rgd', 'sgd', 'GeneDB_Spombe', 'tigr_Soneidensis', 'tigr_Spome
royi', 'GeneDB_Tbrucei', 'tigr_Tbrucei_chr2', 'goa_uniprot', 'tigr_Vcholerae']
>>> go.loadGO()
>>> go.loadAnnotation('sgd')
</XMP>

<h2>Acssessing the loaded data</h2>
<p>The loaded data can be accessed by three fields in the go module:
<ul>
	<li>the <index>loadedGO</index> and </li>
	<li><index>loadedSlimGO</index> whitch are of type GeneOntologyDB</li>
	<li><index>loadedAnnotation</index> of type AnnotationDB</li>
</ul>
</p>

<h2><index>GeneOntologyDB</index></h2>
<index name = "classes+GeneOntologyDB">
<p>An object holding the <index>ontology database</index>.</p>
<p class=section>Members</p>
<dl class=members>
  <dt>terms</dt> 
  <dd>List of instances of GOTerm class holding the details for each term</dd>
  <dt>termDict</dt> 
  <dd>A dictionary mapping GO id's to an instance of GOTerm class with that id</dd>
  <dt>termDescriptorDict</dt> 
  <dd>A dictionary mapping GO id's and alt_id's to a tuple (id, namespace, def, alt_id)</dd>
  <dt>aliasMapper</dt> 
  <dd>A dictionary mapping alt_id's and id's to id's</dd>
</dl>

<h2>AnnotationDB</h2>
<index name = "classes+AnnotationDB">
<p>An object holding the <index>annotation database</index>.</p>
<p class=section>Members</p>
<dl class=members>
  <dt>geneNames</dt>
  <dd>Names of all the genes in the annotation</dd>
  <dt>annotationList</dt>
  <dd>List of instances of Annotation class holding the details for each annotation record</dd>
  <dt>aliasMapper</dt>
  <dd>Alias mapper maps known aliases to gene names (column3 DB_Object_Symbol of annotation file)</dd>
  <dt>geneNamesDict</dt>
  <dd>A dictionary mapping any known alias to a list [DB_Object_ID, DB_Object_Symbol [,DB_Object_Synonym]] i.d. all known names</dd>
  <dt>geneAnnotations</dt>
  <dd>A dictionary mapping gene name (DB_Object_Symbol) to a list of all instances of Annotation with this name</dd>
</dl>

<h2>Mapping aliases to unique names</h2>
<p>There are two dictionaries in the module's namespace for mapping known gene aliases and alternative GOId's to their respected unique identifiers.</p>
<p></b><code>geneMapper</code></b> Maps known gene aliases(DB_Object_Synonym) to DB_Object_Name</p>
<p></b><code>termMapper</code></b> Maps known GOterm alt_id's to unique GOId</p>
<p class="header">Example: mapping gene names from aliases to unique names that can be used in a search (from <a href="golib.py">golib.py</a>)</p>
<XMP class="code">geneNames=[ "YBR085W", ## synonim for AAC3
			"AAD10",
			"21S_rRNA_4" ##synonim for 21S_RRNA
			]
uniqueGeneNames = [go.geneMapper[name] for name in geneNames]
print uniqueGeneNames #should print ["AAC3", "AAD10", "21S_rRNA_4"]
</XMP>

<h2>GOTerm</h2>
<index name = "classes+GOTerm">
<p>Holds the data for one term read from the ontology file. All fields from the ontology can be accsessed by their
original name (e.g. the is_a field in the ontology can be accsessed like term.is_a - for more see <a href="http://geneontology.org/GO.format.obo-1_0.shtml">http://geneontology.org/GO.format.obo-1_0.shtml</a>), except for the def field that
interferes with the python <code>def</code> statment and can be accesed like term._def or term.__dict__['def'].
The fields that can have multiple values are stored as lists of strings otherwise the string after the field name from the
ontology is supplied. If a field is not defined accessing it will result in an exception.
The object also provides the folowing data memebers for quicker accsess: GOId, aspect, parents(list of GOId's of parents terms).</p>
<p class=section>Some of the more frequently used GO tags (Again see <a href="http://geneontology.org/GO.format.obo-1_0.shtml#tags">http://geneontology.org/GO.format.obo-1_0.shtml</a> for more)</p>
<dl class=methods>
  <dt>id</dt>
  <dd>The unique id of the term</dd>
  <dt>name </dt>
  <dd>The term name</dd>
  <dt>alt_id</dt>
  <dd>Defines an alternate id for this term</dd>
  <dt>namespace</dt>
  <dd>The namespace in which the term belongs (biological_process | cellular_component | molecular_function)</dd>
  <dt>_def</dt>
  <dd>The definition of the term</dd>
  <dt>is_a</dt>
  <dd>This tag describes a subclassing relationship between one term and another</dd>
</dl>
<p class="header">Example: printing some details of a GOTerms with keywords "catabolic" and "process" in their names (from <a href="golib.py">golib.py</a>)</p>
<XMP class="code">selectedTerms=filter(lambda term: "catabolic" in term.name and "process" in term.name, go.loadedGO.terms)
for term in selectedTerms:
	print term.id, term.name, term._def
</XMP>

<h2>Annnotation</h2>
<index name = "classes/annotation">
<p>Holds the data for an annotation record read from the annotation file. Fields can be
accessed with the names: DB, DB_Object_ID, DB_Object_Symbol, Qualifier, GO_ID, DB_Reference,
Evidence_code, With_or_From, Aspect, DB_Object_Name, DB_Object_Synonym, DB_Object_Type, taxon,
Date, Assigned_by (e.g. rec.GO_ID)
or by supplying the original name of the field (see <a href="http://geneontology.org/GO.format.annotation.shtml">http://geneontology.org/GO.format.annotation.shtml</a> for further details)
to the get method (e.g. rec.get("GO ID"))
The object also provides the folowing data members for quicker access: geneName, GOId, evidence,
aspect and alias(a list of aliases)</p>
<p class=section>Atributes</p>
<dl class=methods>
  <dt>DB</dt>
  <dd>Refers to the database from which the identifier in DB_Object_ID is drawn.</dd>
  <dt>DB_Object_ID</dt>
  <dd>A unique identifier in DB for the item</dd>
  <dt>DB_Object_Symbol</dt>
  <dd>A (unique and valid) string to which DB_Object_ID s matched</dd>
  <dt>Qualifier</dt>
  <dd>Flags that modify the interpretation of an annotation</dd>
  <dt>GO_ID</dt>
  <dd>GO id to whitch this entry is attributed</dd>
  <dt>DB_Reference</dt>
  <dd></dd>
  <dt>Evidence_code</dt>
  <dd>See <a href="http://geneontology.org/GO.evidence.shtml">http://geneontology.org/GO.evidence.shtml</a></dd>
  <dt>With_or_From</dt>
  <dd></dd>
  <dt>Aspect</dt>
  <dd>One of the strings "P" (biological process), "F" (molecular function) or "C" (cellular component)</dd>
  <dt>DB_Object_Name</dt>
  <dd>name of gene or gene product</dd>
  <dt>DB_Object_Synonym</dt>
  <dd>A list od synonym names for this gene</dd>
  <dt>DB_Object_Type</dt>
  <dd></dd>
  <dt>taxon</dt>
  <dd></dd>
  <dt>Date</dt>
  <dd>Date on which the annotation was made; format is YYYYMMDD</dd>
  <dt>Assigned_by</dt>
  <dd>The database which made the annotation one of the values from the set of <a href="http://geneontology.org/cgi-bin/xrefs.cgi">GO database cross-references</a></dd>
</dl>

<h2>Finding relevant GO terms</h2>
<p>The GOLib's main functionality ...</p>
<p><b><code>GOTermFinder(clusterGeneList, referenceGenes=None, evidenceCodes=None, slimsOnly=False, aspect="P", progressCallback=None)</code></b>-> {GOId : ([geneName, ...], float, int), ...}</p>
<index name = "GOTermFinder">
<p>The method accepts a list of cluster genes, optionally a list of reference genes (otherwise all annotated genes appearing in the loaded annotation file are used),
and optionally a list of annotation evidence codes to use, otherwise all evidence codes are used. The slimsOnly argument indicates if only GO slims are to be used,
otherwise all GO terms are considered. The progressCallback if present will be called with a single argument for all values in range [0..99].
The method returns a dictionary of significant GO terms, items are tuples ([geneName, ...], p-value, nRef) where 
<ul>
  <li>[geneName, ...] is a list of cluster genes that map to the selected term</li>
  <li>p-value is the probability that the mapping of the genes to this term is a coincidence given the reference distribution computed using a binomial distribution.</li>
  <li>nRef is the number of reference genes that map to the term</li>
</ul>
</p>
<p class=section>Arguments</p>
<dl class=arguments>
  <dt>clusterGeneList</dt>
  <dd>A list of gene names for whitch we want to find the matching relevant (w.r.t referenceGenes) GO terms</dd>
  <dt>referenceGenes</dt>
  <dd>A list of gene names used for reference. If None all genes in the currently loaded annotation are used.</dd>
  <dt>evidenceCodes</dt>
  <dd>A list of evidence codes to be considered. Only annotations with evidence in this list will be used. If None all evidences will be used.</dd>
  <dt>slimsOnly</dt>
  <dd>If True only slim terms will be returned (Set the slim terms using the setSlims function).</dd>
  <dt>aspect</dt>
  <dd>A string that determines to whitch top level term should the returned terms belong. Can be any of the folowing
    "biological_process" or shorter "P" ,"cellular_component" or "C", "molecular_function" or "F"</dd>
</dl>
<p class="header">Example: Finding relevant GOTerms and printing them in ascending order (from <a href="golib.py">golib.py</a>)</p>
<XMP class="code">def call(i): print i
res=go.GOTermFinder(uniqueGeneNames, progressCallback=call)
res=res.items()
res.sort(lambda (_1,(_2,a,_3)), (_4,(_5,b,_6)): cmp(a,b))
for GOId,(genes, p, n) in res:
	print GOId, p, genes
</XMP>

<p><b><code>findTerms(geneList, slimsOnly=False, aspect=["F","C","P"], directAnnotationOnly=False, evidenceCodes=None, reportEvidence=True, progressCallback=None)</code></b></p>
<index name= "findTerms">
<p>For each gene in geneList search for matching GO terms. Argument slimsOnly restricts the GO terms to the slim set. The method returns a dictionary where key is a
matching GO term and items are (gene, evidence) if reportEvidence == True [gene only, if reportEvidence=False] that map to the term. Climb the GO if directAnnotationOnly=False,
otherwise report direct annotation only.</p>
<p class=section>Arguments</p>
<dl class=arguments>
  <dt>geneList</dt>
  <dd>List of genes to find the terms for.</dd>
  <dt>slimsOnly</dt>
  <dd>If True only slim terms will be returned (Set the slim terms using the setSlims function).</dd>
  <dt>aspect</dt>
  <dd>A string that determines to whitch top level term should the returned terms belong. Can be any of the folowing
    "biological_process" or shorter "P" ,"cellular_component" or "C", "molecular_function" or "F"</dd>
  <dt>directAnnotationOnly</dt>
  <dd>If true only the terms to whitch the genes map directly will be returned, otherwise all predecessor terms up to the root term will also be returned</dd>
  <dt>evidenceCodes</dt>
  <dd>A list of evidence codes to be considered. Only annotations with evidence in this list will be used. If None all evidences will be used.</dd>
  <dt>reportEvidence</dt>
  <dd>If True a list of evidence codes for each gene-term mapping will also be returned.</dd>
</dl>

<p><b><code>findGenes(GOTerms=[], directAnnotationOnly=False, evidenceCodes=None, reportEvidence=True, progressCallback=None)</code></b></p>
<index name = "findGenes">
<p>Return a dictionary where key is a matching gene and items are (GO terms) or (GO term, list of evidences) from the GOterms list.
(Note this will take a lot of time if the directAnnotationOnly=False)</p>
<p class=section>Arguments</p>
<dl class=arguments>
  <dt>GOTerms</dt>
  <dd>A list of GO terms to find the genes for.</dd>
  <dt>directAnnotationOnly</dt>
  <dd>If true only the terms to whitch the genes map directly will be returned, otherwise all predecessor terms up to the root term will also be returned</dd>
  <dt>evidenceCodes</dt>
  <dd>A list of evidence codes to be considered. Only annotations with evidence in this list will be used. If None all evidences will be used.</dd>
  <dt>reportEvidence</dt>
  <dd>If True a list of evidence codes for each gene-term mapping will also be returned.</dd>
</dl>

<p><b><code>extractGODAG(GOTerms=[])</code></b></p>
<index name ="extractGODAG">
<p>Returns the part of GO DAG that includes the listed GOTerms.</p>
<p class=section>Arguments</p>
<dl class=arguments>
  <dt>GOTerms</dt>
  <dd>A list of GO terms.</dd>
</dl>

<p><b><code>setSlims(slims=None)</code></b></p>
<index name ="setSlims">
<p>Set the slim subset of a loaded ontology. 
<p class=section>Arguments</p>
<dl class=arguments>
  <dt>slims</dt>
  <dd>Can be a:
  <ul>
        <li>-a string identifier of a subsetdef: (e.g. "goslim_generic", "goslim_plant" ...) in the currently loaded ontology</li>
        <li>-a filename of a slim ontology (e.g. "goslim_generic.obo" ...)</li>
        <li>-a list of GO term id's</li>
  </ul>
</dl>

<h2>Visualizing Enrichment Analysis</h2>
<p>GOLib can visualize the enrichment analysis with a cone simple command.</p>
<p><b><code>drawEnrichmentGraph(GOTerms, filename="graph.png", width=None, height=None)</code></b></p>
<index name = "drawEnrichmentGraph">
<p>Draws a graph of GOTerms</p>
<p class=section>Arguments</p>
<dl class=arguments>
  <dt>GOTerms</dt>
  <dd>Dictionary of terms (same structure as returned from GOTermFinder)</dd>
  <dt>filename</dt>
  <dd>Where to save the picture</dd>
  <dt>width, height</dt>
  <dd>Are optional (reasonable defaults are assumed) and serve only as a hint</dd>
</dl>
<p class="header">Example: (from <a href="golib.py">golib.py</a>)</p>
<XMP class="code">terms=go.GOTermFinder(uniqueGeneNames)
terms=go.filterByPValue(terms, 0.2)
go.drawEnrichmentGraph(terms, "enrichment_graph.png", width=600)
</XMP>
<p>produces the folowing image</p>
<img src="enrichment_graph.png">
</body>
</html>
  